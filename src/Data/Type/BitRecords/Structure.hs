{-# LANGUAGE UndecidableInstances #-}
-- | NamedStructure definition for sequences of bits.
--
-- This module provides the core data types and functions for
-- conversion of finite bit sequences from an to conventional (Haskell) data types.
--
-- Non-compressed, non-random finite bit sequences generated by programs are
-- usually compositions of bytes and multi byte words, and a ton of Haskell libraries
-- exist for the serialization and deserialization of ByteStrings.
--
-- This module allows the definition of a __structure__ i.e. a very simple grammar,
-- which allows functions in this library to read and write single bytes, words and bits.
--
-- Also complete bit sequence may be constructed or destructed from and to Haskell types.
--
-- Further more, the Record may contain dependent sub-sequences, for example to
-- express Record that precede a /length/ field before a repetitive block data.
--
-- Antother example for dependent sequences is /fields/ whose presence depends on
-- /flags/ preceding them.
--
-- This library is also designed with /zero copying/ in mind.
--
-- It should be emphasized that binary deserialization __is not__
-- to be confused with binary destructuring. While the former usually involves copying
-- all regular sub sequences from the input to a value of a certain type, the later
-- merely requires to peek into the sequeuence at a certain position and deserializing
-- a sub sequence. The starting position and the interpretation are governed by the
-- strucuture applied to the sequence.

module Data.Type.BitRecords.Structure where

import           Data.Int
import           Data.Kind                      ( Type )
import           Data.Kind.Extra
import           Data.Proxy
import           Data.Type.Pretty
import           Data.Word
import           GHC.TypeLits
import           Text.Printf
import Data.Tagged
import Data.Type.Bool
import Data.Type.Equality (type (==))
import Numeric.Natural
import Test.TypeSpec
import Data.Type.BitRecords.TypeLits

-- | Phantom type for structured data
data Structure = MkStructure

-- | The number of bits that a structure with a predetermined fixed length requires.
type family BitCount (t :: To Structure) :: Nat

-- | The class accompanying 'Structure' derivatives
-- | The type signature of a constructor (function) for a structure
type family Constructor (t :: To Structure) next :: k

-- | Support for Pretty Printing 'Structure' Types
type family PrettyStructure (struct :: To Structure) :: PrettyType

type instance ToPretty (struct :: To Structure) = PrettyStructure struct

-- | Support assinging type literals as constant values to Record
type family StructureLiteral (strict :: To Structure) :: To TypeLit

-- | Empty Structure
data EmptyStructure :: To Structure

type instance BitCount EmptyStructure = 0
type instance Constructor EmptyStructure next = next
type instance PrettyStructure EmptyStructure = 'PrettyEmpty
type instance StructureLiteral EmptyStructure = EmptyLiteral

type instance BitCount (Anonymous (Name name struct)) = BitCount struct
type instance Constructor (Anonymous (Name name struct)) next = Constructor struct next
type instance PrettyStructure (Anonymous (Name name struct)) = name <:> PrettyStructure struct
type instance StructureLiteral (Anonymous (Name name struct)) = StructureLiteral struct

-- | A record is a list of fields, 'Name' 'Structure' composed of a list of other Record in natural order.
data Record :: [To (Named Structure)] -> To Structure

type instance BitCount (Record '[]) = 0
type instance BitCount (Record (x ': xs)) = BitCount (Anonymous x) + BitCount (Record xs)
type instance Constructor (Record ('[] :: [To (Named Structure)])) next = next
type instance Constructor (Record (x ': xs)) next = Constructor (Anonymous x) (Constructor (Record xs) next)

type instance PrettyStructure (Record xs) = "Record" <:$$--> PrettyRecord xs

type family (<>) (a :: To (Named Structure)) (b :: k) :: To Structure where
  a <> (b :: To (Named Structure)) = Record '[a, b]
  a <> (Record xs) = Record (a ': xs)
infixr 6 <>

type family PrettyRecord (xs :: [To (Named Structure)]) :: PrettyType where
  PrettyRecord '[] = 'PrettyEmpty
  PrettyRecord (x ': xs) =
    (PutStr "-" <+> PrettyStructure (Anonymous x)) <$$> PrettyRecord xs

type instance StructureLiteral (Record '[]) = EmptyLiteral
type instance StructureLiteral (Record (x ': xs)) = NatLiteral

-- | A fixed length sequence of bits.
data BitSequence (length :: Nat) :: To Structure

type family WithValidBitSequenceLength (length :: Nat) (out :: k) :: k where
  WithValidBitSequenceLength length out =
    If (length <=? 64 && 1 <=? length )
      out
      (TypeError ('Text "invalid bit sequence length: " ':<>: 'ShowType length))

type family (//) (name :: Symbol) (length :: Nat) :: To (Named Structure) where
  name // length =
    WithValidBitSequenceLength length (Name name (BitSequence length))

infixr 7 //

type instance BitCount (BitSequence length) =
  WithValidBitSequenceLength length length
type instance Constructor (BitSequence length) next =
  WithValidBitSequenceLength length (Word64 -> next)
type instance PrettyStructure (BitSequence length) =
  WithValidBitSequenceLength length (PutStr "BitSequence " <+> PutNat length)
type instance StructureLiteral (BitSequence length) =
  WithValidBitSequenceLength length (ValidBitsLiteral length)


-- | A constant, fixed length sequence of bits.
data ConstantStructure :: t 'MkTypeLit -> To Structure

type instance BitCount (ConstantStructure r) = TypeLitBits r
type instance Constructor (ConstantStructure r) next = next
type instance PrettyStructure (ConstantStructure r) = "ConstantStructure" <:> ToPretty r
type instance StructureLiteral (ConstantStructure length) = EmptyLiteral

-- ** Integer Sequences

-- | A Wrapper for Haskell types. Users should implement the 'BitCount' and 'Constructor' instances.
data TypeStructure :: Type -> To Structure

type U8 = TypeStructure Word8
type instance BitCount (TypeStructure Word8) = 8
type instance Constructor (TypeStructure Word8) next = Word8 -> next
type instance PrettyStructure (TypeStructure Word8) = ToPretty Word8
type instance StructureLiteral (TypeStructure Word8) = NatLiteral

type S8 = TypeStructure Int8
type instance BitCount (TypeStructure Int8) = 8
type instance Constructor (TypeStructure Int8) next = Int8 -> next
type instance PrettyStructure (TypeStructure Int8) = ToPretty Int8
type instance StructureLiteral (TypeStructure Int8) = SignedNatLiteral

type FlagStructure = TypeStructure Bool
type instance BitCount (TypeStructure Bool) = 1
type instance Constructor (TypeStructure Bool) next = Bool -> next
type instance PrettyStructure (TypeStructure Bool) = ToPretty Bool
type instance StructureLiteral (TypeStructure Bool) = FlagLiteral

-- | Structure holding integral numbers
data IntegerStructure :: Nat -> Sign -> Endianess -> To Structure where
  S16LE :: Int16 -> IntegerStructure 16 'Signed 'LE 'MkStructure
  S16BE :: Int16 -> IntegerStructure 16 'Signed 'BE 'MkStructure
  U16LE :: Word16 -> IntegerStructure 16 'Unsigned 'LE 'MkStructure
  U16BE :: Word16 -> IntegerStructure 16 'Unsigned 'BE 'MkStructure
  S32LE :: Int32 -> IntegerStructure 32 'Signed 'LE 'MkStructure
  S32BE :: Int32 -> IntegerStructure 32 'Signed 'BE 'MkStructure
  U32LE :: Word32 -> IntegerStructure 32 'Unsigned 'LE 'MkStructure
  U32BE :: Word32 -> IntegerStructure 32 'Unsigned 'BE 'MkStructure
  S64LE :: Int64 -> IntegerStructure 64 'Signed 'LE 'MkStructure
  S64BE :: Int64 -> IntegerStructure 64 'Signed 'BE 'MkStructure
  U64LE :: Word64 -> IntegerStructure 64 'Unsigned 'LE 'MkStructure
  U64BE :: Word64 -> IntegerStructure 64 'Unsigned 'BE 'MkStructure

-- | Endianess of an 'IntegerStructure'
data Endianess = LE | BE

-- | Integer sign of an 'IntegerStructure'
data Sign = Signed | Unsigned

type family WithValidIntegerStructureLength (n :: Nat) (out :: k) where
  WithValidIntegerStructureLength n out =
    If (n == 16) out (If (n == 32) out (If (n == 64) out
      (TypeError ('Text "Invalid IntegerStructure size: " ':<>: 'ShowType n))))

type instance BitCount (IntegerStructure n s e) = WithValidIntegerStructureLength n n
type instance Constructor (IntegerStructure n s e) next   =
  WithValidIntegerStructureLength n (IntegerStructure n s e 'MkStructure -> next)
type instance PrettyStructure (IntegerStructure n s e) =
  WithValidIntegerStructureLength n
    (PutStr "IntegerStructure"
    <+> PutNat n
    <+> If (s == 'Signed) (PutStr "Signed") (PutStr "Unsigned")
    <+> If (e == 'BE) (PutStr "BE") (PutStr "LE"))
type instance StructureLiteral (IntegerStructure n s e) =
  WithValidIntegerStructureLength n
    (If (s == 'Signed) SignedNatLiteral NatLiteral)

type U n e = IntegerStructure n 'Unsigned e
type S n e = IntegerStructure n 'Signed e

-- | Structure consisting of predefined type level literal values.


-- | Compile time fixed content structure aliased to existing 'Structure'.
data Assign (struct :: To Structure)
  :: ToTypeLit (StructureLiteral struct) -> To Structure

type family WithValidLiteralSize (struct :: To Structure) arg (out :: k) :: k where
  WithValidLiteralSize struct value out =
    If (TypeLitBits value <=? BitCount struct)
      out
      (TypeError ('Text "Assign value too big to fit into structure, the value " ':<>: 'ShowType value
                  ':<>: 'Text " requires " ':<>: 'ShowType (TypeLitBits value)
                  ':<>: 'Text " bits, but the structure "  ':<>: 'ShowType struct
                  ':<>: 'Text " has only a size of " ':<>: 'ShowType (BitCount struct)
                  ':<>: 'Text " bits."))

type instance BitCount (Assign s a) = WithValidLiteralSize s a (BitCount s)
type instance Constructor (Assign s a) next =
  WithValidLiteralSize s a next
type instance PrettyStructure (Assign s a) =
  WithValidLiteralSize s a
    (PutStr "Assign" <+> ToPretty s <+> ToPretty a)
type instance StructureLiteral (Assign s a) =
  TypeError ('Text "Cannot assign a constant value twice: " ':<>: 'ShowType (Assign s a))

data ConditionalStructure (condition :: Bool) (ifStruct :: To Structure) (elseStruct :: To Structure) :: To Structure

type instance BitCount (ConditionalStructure 'True l r) = BitCount l
type instance BitCount (ConditionalStructure 'False l r) = BitCount r
type instance Constructor (ConditionalStructure 'True l r) next = Constructor l next
type instance Constructor (ConditionalStructure 'False l r) next = Constructor r next
type instance PrettyStructure (ConditionalStructure 'True l r) = PrettyStructure l
type instance PrettyStructure (ConditionalStructure 'False l r) = PrettyStructure r
type instance StructureLiteral (ConditionalStructure 'True l r) = StructureLiteral l
type instance StructureLiteral (ConditionalStructure 'False l r) = StructureLiteral r

-- * Structure PrettyType Printing

-- | Render @struct@ to a pretty, human readable form. Internally this is a wrapper
-- around 'ptShow' using 'PrettyStructure'.
showStructure
  :: forall proxy (struct :: To Structure)
   . PrettyTypeShow (PrettyStructure struct)
  => proxy struct
  -> String
showStructure _ = showPretty (Proxy :: Proxy (PrettyStructure struct))


-- -------------------------------------------
-- Tests
-- -------------------------------------------

data BoolProxy (t :: Bool) where
  TrueProxy :: BoolProxy 'True
  FalseProxy :: BoolProxy 'False

_typeSpecBitCount
  :: BoolProxy (testBool :: Bool)
  -> Expect [ BitCount U8 `ShouldBe` 8
            , BitCount EmptyStructure `ShouldBe` 0
            , BitCount (Record [Name "x" U8, Name "y" U8]) `ShouldBe` 16
            , BitCount (S 16 'BE) `ShouldBe` 16
            , BitCount (ConditionalStructure testBool (U 32 'LE) S8) `ShouldBe` (If testBool 32 8)
            , BitCount ("field 1"//3 <> "field 2"//2 <> "field 3"//5 <>
                          Name "field 4" ("field 4.1"//3 <> "field 4.2"//6))
                         `ShouldBe` 19
            , BitCount (Assign (BitSequence 4) (BitsLiteral '[1,0,0,1])) `ShouldBe` 4
            ]
_typeSpecBitCount TrueProxy = Valid
_typeSpecBitCount FalseProxy = Valid

_typeSpecStructureLiteral
  :: BoolProxy (testBool :: Bool)
  -> Expect [ StructureLiteral EmptyStructure `ShouldBe` EmptyLiteral
            , StructureLiteral U8 `ShouldBe` NatLiteral
            , StructureLiteral S8 `ShouldBe` SignedNatLiteral
            , StructureLiteral FlagStructure `ShouldBe` FlagLiteral
            , StructureLiteral (Anonymous (Name "foo" S8)) `ShouldBe` StructureLiteral S8
            , StructureLiteral (Record [Name "x" U8, Name "y" U8]) `ShouldBe` NatLiteral
            , StructureLiteral (S 16 'BE) `ShouldBe` SignedNatLiteral
            , StructureLiteral (U 16 'BE) `ShouldBe` NatLiteral
            , StructureLiteral (S 32 'BE) `ShouldBe` SignedNatLiteral
            , StructureLiteral (U 32 'BE) `ShouldBe` NatLiteral
            , StructureLiteral (S 64 'BE) `ShouldBe` SignedNatLiteral
            , StructureLiteral (U 64 'BE) `ShouldBe` NatLiteral
            , StructureLiteral (S 16 'LE) `ShouldBe` SignedNatLiteral
            , StructureLiteral (U 16 'LE) `ShouldBe` NatLiteral
            , StructureLiteral (S 32 'LE) `ShouldBe` SignedNatLiteral
            , StructureLiteral (U 32 'LE) `ShouldBe` NatLiteral
            , StructureLiteral (S 64 'LE) `ShouldBe` SignedNatLiteral
            , StructureLiteral (U 64 'LE) `ShouldBe` NatLiteral
            , StructureLiteral (ConditionalStructure testBool (U 32 'LE) S8)
                `ShouldBe` (If testBool NatLiteral SignedNatLiteral)
            , StructureLiteral ("field 1"//3 <> "field 2"//2 <> "field 3"//5 <>
                               Name "field 4" ("field 4.1"//3 <> "field 4.2"//6))
                              `ShouldBe` NatLiteral
            , StructureLiteral (ConstantStructure (BitsLiteral [1,0,0])) `ShouldBe` EmptyLiteral
            , StructureLiteral (BitSequence 19) `ShouldBe` (ValidBitsLiteral 19)
            ]
_typeSpecStructureLiteral TrueProxy = Valid
_typeSpecStructureLiteral FalseProxy = Valid

_constructorSpec :: ()
_constructorSpec =
    (undefined :: Constructor U8 ())          (undefined :: Word8 )
  <> (undefined :: Constructor S8 ())         (undefined :: Int8 )
  <> (undefined :: Constructor FlagStructure ()) (undefined :: Bool )
  <> (undefined :: Constructor (S 16 'BE) ()) (undefined :: IntegerStructure 16 'Signed 'BE  'MkStructure )
  <> (undefined :: Constructor (U 16 'BE) ()) (undefined :: IntegerStructure 16 'Unsigned 'BE  'MkStructure )
  <> (undefined :: Constructor (S 16 'LE) ()) (undefined :: IntegerStructure 16 'Signed 'LE  'MkStructure )
  <> (undefined :: Constructor (U 16 'LE) ()) (undefined :: IntegerStructure 16 'Unsigned 'LE  'MkStructure )
  <> (undefined :: Constructor (S 32 'BE) ()) (undefined :: IntegerStructure 32 'Signed 'BE  'MkStructure )
  <> (undefined :: Constructor (U 32 'BE) ()) (undefined :: IntegerStructure 32 'Unsigned 'BE  'MkStructure )
  <> (undefined :: Constructor (S 32 'LE) ()) (undefined :: IntegerStructure 32 'Signed 'LE  'MkStructure )
  <> (undefined :: Constructor (U 32 'LE) ()) (undefined :: IntegerStructure 32 'Unsigned 'LE  'MkStructure )
  <> (undefined :: Constructor (S 64 'BE) ()) (undefined :: IntegerStructure 64 'Signed 'BE  'MkStructure )
  <> (undefined :: Constructor (U 64 'BE) ()) (undefined :: IntegerStructure 64 'Unsigned 'BE  'MkStructure )
  <> (undefined :: Constructor (S 64 'LE) ()) (undefined :: IntegerStructure 64 'Signed 'LE  'MkStructure )
  <> (undefined :: Constructor (U 64 'LE) ()) (undefined :: IntegerStructure 64 'Unsigned 'LE  'MkStructure )
  <> (undefined :: Constructor (Anonymous (Name "foo" U8)) ()) (undefined :: Word8 )
  <> (undefined :: Constructor (Assign (Name "foo" U8 <> Name "bar" FlagStructure) (MkNat 256)) ())
  <> (undefined :: Constructor (Record '[]) ())
  <> (undefined :: Constructor EmptyStructure ())
  <> (undefined :: Constructor (BitSequence 15) ()) (undefined :: Word64)
  <> (undefined :: Constructor (ConditionalStructure  'True  (Record '[]) U8) ())
  <> (undefined :: Constructor (ConditionalStructure  'False  (Record '[]) U8) ()) (undefined :: Word8)
  <> (undefined :: Constructor (Record '[Name "x" U8, Name "y" S8]) ()) (undefined :: Word8 ) (undefined :: Int8 )
  <> (undefined :: Constructor (Name "x" U8 <> Name "y" S8 <> Name "z" S8) ()) (undefined :: Word8 ) (undefined :: Int8 ) (undefined :: Int8 )
  <> (undefined :: Constructor (ConstantStructure (BitsLiteral [1,0,1,0])) ())

_prettySpec ::
  Proxy (
      PrettyHigh '[
         PrettyStructure EmptyStructure
        , PrettyStructure (Anonymous (Name "foo" U8))
        , PrettyStructure U8
        , PrettyStructure S8
        , PrettyStructure FlagStructure
        , PrettyStructure (S 16 'LE)
        , PrettyStructure (S 32 'LE)
        , PrettyStructure (S 64 'LE)
        , PrettyStructure (U 16 'LE)
        , PrettyStructure (U 32 'LE)
        , PrettyStructure (U 64 'LE)
        , PrettyStructure (S 16 'BE)
        , PrettyStructure (S 32 'BE)
        , PrettyStructure (S 64 'BE)
        , PrettyStructure (U 16 'BE)
        , PrettyStructure (U 32 'BE)
        , PrettyStructure (U 64 'BE)
        , PrettyStructure ("x"//32 <> "y"//32 <> "z"//8)
        , PrettyStructure (ConditionalStructure 'False S8 U8)
        , PrettyStructure (ConditionalStructure 'True S8 U8)
        , PrettyStructure (Assign S8 ('Positive 123))
        ]
    )
  -> String
_prettySpec px = showPretty px
