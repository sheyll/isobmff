{-# LANGUAGE UndecidableInstances #-}
-- | NamedStructure definition for sequences of bits.
--
-- This module provides the core data types and functions for
-- conversion of finite bit sequences from an to conventional (Haskell) data types.
--
-- Non-compressed, non-random finite bit sequences generated by programs are
-- usually compositions of bytes and multi byte words, and a ton of Haskell libraries
-- exist for the serialization and deserialization of ByteStrings.
--
-- This module allows the definition of a __structure__ i.e. a very simple grammar,
-- which allows functions in this library to read and write single bytes, words and bits.
--
-- Also complete bit sequence may be constructed or destructed from and to Haskell types.
--
-- Further more, the structures may contain dependent sub-sequences, for example to
-- express structures that precede a /length/ field before a repetitive block data.
--
-- Antother example for dependent sequences is /fields/ whose presence depends on
-- /flags/ preceding them.
--
-- This library is also designed with /zero copying/ in mind.
--
-- It should be emphasized that binary deserialization __is not__
-- to be confused with binary destructuring. While the former usually involves copying
-- all regular sub sequences from the input to a value of a certain type, the later
-- merely requires to peek into the sequeuence at a certain position and deserializing
-- a sub sequence. The starting position and the interpretation are governed by the
-- strucuture applied to the sequence.

module Data.Type.BitRecords.Structure where

import           Data.Int
import           Data.Kind                      ( Type )
import           Data.Kind.Extra
import           Data.Proxy
import           Data.Type.Pretty
import           Data.Word
import           GHC.TypeLits
import           Text.Printf
import Data.Tagged
import Data.Type.Bool
import Data.Type.Equality (type (==))
import Numeric.Natural
import Test.TypeSpec

-- | Phantom type for structured data
data Structure = MkStructure

-- | The number of bits that a structure with a predetermined fixed length requires.
type family BitCount (t :: To Structure) :: Nat

-- | The type signature of a constructor (function) for a structure
type family Constructor (t :: To Structure) (next) :: k

-- | Support for Pretty Printing 'Structure' Types
type family PrettyStructure (struct :: To Structure) :: PrettyType
type instance ToPretty (struct :: To Structure) = PrettyStructure struct

-- | Support assinging type literals as constant values to structures
type family StructureLiteral (strict :: To Structure) :: To TypeLit

-- | Empty Structure
data EmptyStructure :: To Structure

type instance BitCount EmptyStructure = 0
type instance Constructor EmptyStructure next = next
type instance PrettyStructure EmptyStructure = 'PrettyEmpty
type instance StructureLiteral EmptyStructure = EmptyLiteral

data TypeLit = MkTypeLit

data Promoting (t :: To b)  (tt :: t (k :: b))

-- | An empty type literal
data EmptyLiteral :: To TypeLit where
  MkEmptyLiteral :: EmptyLiteral 'MkTypeLit

type instance ToPretty 'MkEmptyLiteral = PrettyEmpty

-- | A Signed type literal number
data SignedNatLiteral :: To TypeLit where
  Positive :: Nat -> SignedNatLiteral 'MkTypeLit
  Negative :: Nat -> SignedNatLiteral 'MkTypeLit

type instance ToPretty ('Positive x) = PutNat x
type instance ToPretty ('Negative x) = PutStr "-" <++> PutNat x

-- | Passthrough predefined type literals
data NatLiteral :: To TypeLit where
  MkNat :: Nat -> NatLiteral 'MkTypeLit

type instance ToPretty ('MkNat x) = PutBits x

-- | A Bool literal
data FlagLiteral :: To TypeLit where
  MkFlag :: Bool -> FlagLiteral 'MkTypeLit

type instance ToPretty ('MkFlag x ) = ToPretty x

type instance BitCount (Anonymous (Name name struct)) = BitCount struct
type instance Constructor (Anonymous (Name name struct)) next = Constructor struct next
type instance PrettyStructure (Anonymous (Name name struct)) = name <:> PrettyStructure struct
type instance StructureLiteral (Anonymous (Name name struct)) = StructureLiteral struct

-- | A 'NamedStructure' composed of a list of other structures in natural order.
data CompoundStructure :: [To (Named Structure)] -> To Structure

type instance BitCount (CompoundStructure '[]) = 0
type instance BitCount (CompoundStructure (x ': xs)) = BitCount (Anonymous x) + BitCount (CompoundStructure xs)
type instance Constructor (CompoundStructure ('[] :: [To (Named Structure)])) next = next
type instance Constructor (CompoundStructure (x ': xs)) next = Constructor (Anonymous x) (Constructor (CompoundStructure xs) next)

type instance PrettyStructure (CompoundStructure xs) = "CompoundStructure" <:$$--> PrettyCompoundStructure xs

type family (<>) (a :: To (Named Structure)) (b :: k) :: To Structure where
  a <> (b :: To (Named Structure)) = CompoundStructure '[a, b]
  a <> (CompoundStructure xs) = CompoundStructure (a ': xs)
infixr 6 <>

type family PrettyCompoundStructure (xs :: [To (Named Structure)]) :: PrettyType where
  PrettyCompoundStructure '[] = 'PrettyEmpty
  PrettyCompoundStructure (x ': xs) =
    (PutStr "-" <+> PrettyStructure (Anonymous x)) <$$> PrettyCompoundStructure xs

type instance StructureLiteral (CompoundStructure '[]) = EmptyLiteral
type instance StructureLiteral (CompoundStructure (x ': xs)) = NatLiteral

-- | A fixed length sequence of bits.
data BitSequence (length :: Nat) :: To Structure

type family WithValidBitSequenceLength (length :: Nat) (out :: k) :: k where
  WithValidBitSequenceLength length out =
    If (length <=? 64 && 1 <=? length )
      out
      (TypeError ('Text "invalid bit sequence length: " ':<>: 'ShowType length))

type family (//) (name :: Symbol) (length :: Nat) :: To (Named Structure) where
  name // length =
    WithValidBitSequenceLength length (Name name (BitSequence length))

infixr 7 //

type instance BitCount (BitSequence length) =
  WithValidBitSequenceLength length length
type instance Constructor (BitSequence length) next =
  WithValidBitSequenceLength length (Word64 -> next)
type instance PrettyStructure (BitSequence length) =
  WithValidBitSequenceLength length (PutStr "BitSequence " <+> PutNat length)
type instance StructureLiteral (BitSequence length) =
  WithValidBitSequenceLength length NatLiteral
-- ** Integer Sequences

-- | A Wrapper for Haskell types. Users should implement the 'BitCount' and 'Constructor' instances.
data TypeStructure :: Type -> To Structure

type U8 = TypeStructure Word8
type instance BitCount (TypeStructure Word8) = 8
type instance Constructor (TypeStructure Word8) next = Word8 -> next
type instance PrettyStructure (TypeStructure Word8) = ToPretty Word8
type instance StructureLiteral (TypeStructure Word8) = NatLiteral

type S8 = TypeStructure Int8
type instance BitCount (TypeStructure Int8) = 8
type instance Constructor (TypeStructure Int8) next = Int8 -> next
type instance PrettyStructure (TypeStructure Int8) = ToPretty Int8
type instance StructureLiteral (TypeStructure Int8) = SignedNatLiteral

type FlagStructure = TypeStructure Bool
type instance BitCount (TypeStructure Bool) = 1
type instance Constructor (TypeStructure Bool) next = Bool -> next
type instance PrettyStructure (TypeStructure Bool) = ToPretty Bool
type instance StructureLiteral (TypeStructure Bool) = FlagLiteral

-- | Structure holding integral numbers
data IntegerStructure :: Nat -> Sign -> Endianess -> To Structure where
  S16LE :: Int16 -> IntegerStructure 16 'Signed 'LE 'MkStructure
  S16BE :: Int16 -> IntegerStructure 16 'Signed 'BE 'MkStructure
  U16LE :: Word16 -> IntegerStructure 16 'Unsigned 'LE 'MkStructure
  U16BE :: Word16 -> IntegerStructure 16 'Unsigned 'BE 'MkStructure
  S32LE :: Int32 -> IntegerStructure 32 'Signed 'LE 'MkStructure
  S32BE :: Int32 -> IntegerStructure 32 'Signed 'BE 'MkStructure
  U32LE :: Word32 -> IntegerStructure 32 'Unsigned 'LE 'MkStructure
  U32BE :: Word32 -> IntegerStructure 32 'Unsigned 'BE 'MkStructure
  S64LE :: Int64 -> IntegerStructure 64 'Signed 'LE 'MkStructure
  S64BE :: Int64 -> IntegerStructure 64 'Signed 'BE 'MkStructure
  U64LE :: Word64 -> IntegerStructure 64 'Unsigned 'LE 'MkStructure
  U64BE :: Word64 -> IntegerStructure 64 'Unsigned 'BE 'MkStructure

-- | Endianess of an 'IntegerStructure'
data Endianess = LE | BE

-- | Integer sign of an 'IntegerStructure'
data Sign = Signed | Unsigned

type family WithValidIntegerStructureLength (n :: Nat) (out :: k) where
  WithValidIntegerStructureLength n out =
    If (n == 16) out (If (n == 32) out (If (n == 64) out
      (TypeError ('Text "Invalid IntegerStructure size: " ':<>: 'ShowType n))))

type instance BitCount (IntegerStructure n s e) = WithValidIntegerStructureLength n n
type instance Constructor (IntegerStructure n s e) next   =
  WithValidIntegerStructureLength n (IntegerStructure n s e 'MkStructure -> next)
type instance PrettyStructure (IntegerStructure n s e) =
  WithValidIntegerStructureLength n
    (PutStr "IntegerStructure"
    <+> PutNat n
    <+> If (s == 'Signed) (PutStr "Signed") (PutStr "Unsigned")
    <+> If (e == 'BE) (PutStr "BE") (PutStr "LE"))
type instance StructureLiteral (IntegerStructure n s e) =
  WithValidIntegerStructureLength n
    (If (s == 'Signed) SignedNatLiteral NatLiteral)

type U n e = IntegerStructure n 'Unsigned e
type S n e = IntegerStructure n 'Signed e

-- | Assign a constant number value to some structure.
data ConstantStructure
  :: Promoting (StructureLiteral struct) literal -> struct 'MkStructure -> To Structure


-- | Calculate the number of bits require to represent the given type literal value
type family TypeLitBits (value :: k) :: Nat

type instance TypeLitBits (MkNat v ) = NatBits v
type instance TypeLitBits (Positive v) = NatBits v + 1
type instance TypeLitBits (Negative v) = NatBits v + 1
type instance TypeLitBits (MkFlag v) = 1

type family NatBits (value :: Nat) :: Nat where
  NatBits 0 = 1
  NatBits n = Log2 n + 1

type family WithValidConstantStructureSize (tl :: To TypeLit) (value :: tl 'MkTypeLit) (struct :: To Structure) (out :: k) :: k where
  WithValidConstantStructureSize x value struct out =
    If (TypeLitBits value <=? BitCount struct)
      out
      (TypeError ('Text "ConstantStructure value too big to fit into structure, the value " ':<>: 'ShowType value
                  ':<>: 'Text " requires " ':<>: 'ShowType (TypeLitBits value)
                  ':<>: 'Text " bits, but the structure "  ':<>: 'ShowType struct
                  ':<>: 'Text " has only a size of " ':<>: 'ShowType (BitCount struct)
                  ':<>: 'Text " bits."))

type instance BitCount (ConstantStructure t n s) = WithValidConstantStructureSize t n s (BitCount s)
type instance Constructor (ConstantStructure t val struct) next =
  WithValidConstantStructureSize t val struct next
type instance PrettyStructure (ConstantStructure t n s) =
  WithValidConstantStructureSize t n s
    (PutStr "ConstantStructure" <+> ToPretty n <+> PrettyStructure s)
type instance StructureLiteral (ConstantStructure t n s) =
  TypeError ('Text "Cannot assign a constant value twice: " ':<>: 'ShowType (ConstantStructure t n s))

data ConditionalStructure (condition :: Bool) (ifStruct :: To Structure) (elseStruct :: To Structure) :: To Structure

type instance BitCount (ConditionalStructure 'True l r) = BitCount l
type instance BitCount (ConditionalStructure 'False l r) = BitCount r
type instance Constructor (ConditionalStructure 'True l r) next = Constructor l next
type instance Constructor (ConditionalStructure 'False l r) next = Constructor r next
type instance PrettyStructure (ConditionalStructure 'True l r) = PrettyStructure l
type instance PrettyStructure (ConditionalStructure 'False l r) = PrettyStructure r
type instance StructureLiteral (ConditionalStructure 'True l r) = StructureLiteral l
type instance StructureLiteral (ConditionalStructure 'False l r) = StructureLiteral r

-- * Structure PrettyType Printing

-- | Render @struct@ to a pretty, human readable form. Internally this is a wrapper
-- around 'ptShow' using 'PrettyStructure'.
showStructure
  :: forall proxy (struct :: To Structure)
   . PrettyTypeShow (PrettyStructure struct)
  => proxy struct
  -> String
showStructure _ = showPretty (Proxy :: Proxy (PrettyStructure struct))


-- -------------------------------------------
-- Tests
-- -------------------------------------------

data BoolProxy (t :: Bool) where
  TrueProxy :: BoolProxy 'True
  FalseProxy :: BoolProxy 'False

_typeSpecBitCount
  :: BoolProxy (testBool :: Bool)
  -> Expect [ BitCount U8 `ShouldBe` 8
            , BitCount EmptyStructure `ShouldBe` 0
            , BitCount (CompoundStructure [Name "x" U8, Name "y" U8]) `ShouldBe` 16
            , BitCount (S 16 'BE) `ShouldBe` 16
            , BitCount (ConditionalStructure testBool (U 32 'LE) S8) `ShouldBe` (If testBool 32 8)
            , BitCount ("field 1"//3 <> "field 2"//2 <> "field 3"//5 <>
                          Name "field 4" ("field 4.1"//3 <> "field 4.2"//6))
                         `ShouldBe` 19
            , BitCount (ConstantStructure 0 (BitSequence 4)) `ShouldBe` 4
            ]
_typeSpecBitCount TrueProxy = Valid
_typeSpecBitCount FalseProxy = Valid

_typeSpecStructureLiteral
  :: BoolProxy (testBool :: Bool)
  -> Expect [ StructureLiteral EmptyStructure `ShouldBe` EmptyLiteral
            -- , StructureLiteral U8 `ShouldBe` Nat
            -- , StructureLiteral S8 `ShouldBe` SignedNatLiteral
            -- , StructureLiteral FlagStructure `ShouldBe` Bool
            -- , StructureLiteral (Anonymous (Name "foo" S8)) `ShouldBe` StructureLiteral S8
            -- , StructureLiteral EmptyStructure `ShouldBe` '()
            -- , StructureLiteral (CompoundStructure [Name "x" U8, Name "y" U8]) `ShouldBe` Nat
            -- , StructureLiteral (S 16 'BE) `ShouldBe` SignedNatLiteral
            -- , StructureLiteral (U 16 'BE) `ShouldBe` Nat
            -- , StructureLiteral (S 32 'BE) `ShouldBe` SignedNatLiteral
            -- , StructureLiteral (U 32 'BE) `ShouldBe` Nat
            -- , StructureLiteral (S 64 'BE) `ShouldBe` SignedNatLiteral
            -- , StructureLiteral (U 64 'BE) `ShouldBe` Nat
            -- , StructureLiteral (S 16 'LE) `ShouldBe` SignedNatLiteral
            -- , StructureLiteral (U 16 'LE) `ShouldBe` Nat
            -- , StructureLiteral (S 32 'LE) `ShouldBe` SignedNatLiteral
            -- , StructureLiteral (U 32 'LE) `ShouldBe` Nat
            -- , StructureLiteral (S 64 'LE) `ShouldBe` SignedNatLiteral
            -- , StructureLiteral (U 64 'LE) `ShouldBe` Nat
            -- , StructureLiteral (ConditionalStructure testBool (U 32 'LE) S8) `ShouldBe` (If testBool Nat SignedNatLiteral)
            -- , StructureLiteral ("field 1"//3 <> "field 2"//2 <> "field 3"//5 <>
            --                    Name "field 4" ("field 4.1"//3 <> "field 4.2"//6))
            --                   `ShouldBe` Nat
            ]
_typeSpecStructureLiteral TrueProxy = Valid
_typeSpecStructureLiteral FalseProxy = Valid

_constructorSpec :: ()
_constructorSpec =
    (undefined :: Constructor U8 ())          (undefined :: Word8 )
  <> (undefined :: Constructor S8 ())         (undefined :: Int8 )
  <> (undefined :: Constructor FlagStructure ()) (undefined :: Bool )
  <> (undefined :: Constructor (S 16 'BE) ()) (undefined :: IntegerStructure 16 'Signed 'BE  'MkStructure )
  <> (undefined :: Constructor (U 16 'BE) ()) (undefined :: IntegerStructure 16 'Unsigned 'BE  'MkStructure )
  <> (undefined :: Constructor (S 16 'LE) ()) (undefined :: IntegerStructure 16 'Signed 'LE  'MkStructure )
  <> (undefined :: Constructor (U 16 'LE) ()) (undefined :: IntegerStructure 16 'Unsigned 'LE  'MkStructure )
  <> (undefined :: Constructor (S 32 'BE) ()) (undefined :: IntegerStructure 32 'Signed 'BE  'MkStructure )
  <> (undefined :: Constructor (U 32 'BE) ()) (undefined :: IntegerStructure 32 'Unsigned 'BE  'MkStructure )
  <> (undefined :: Constructor (S 32 'LE) ()) (undefined :: IntegerStructure 32 'Signed 'LE  'MkStructure )
  <> (undefined :: Constructor (U 32 'LE) ()) (undefined :: IntegerStructure 32 'Unsigned 'LE  'MkStructure )
  <> (undefined :: Constructor (S 64 'BE) ()) (undefined :: IntegerStructure 64 'Signed 'BE  'MkStructure )
  <> (undefined :: Constructor (U 64 'BE) ()) (undefined :: IntegerStructure 64 'Unsigned 'BE  'MkStructure )
  <> (undefined :: Constructor (S 64 'LE) ()) (undefined :: IntegerStructure 64 'Signed 'LE  'MkStructure )
  <> (undefined :: Constructor (U 64 'LE) ()) (undefined :: IntegerStructure 64 'Unsigned 'LE  'MkStructure )
  <> (undefined :: Constructor (Anonymous (Name "foo" U8)) ()) (undefined :: Word8 )
  <> (undefined :: Constructor (ConstantStructure 256 (Name "foo" U8 <> Name "bar" FlagStructure)) ())
  <> (undefined :: Constructor (CompoundStructure '[]) ())
  <> (undefined :: Constructor EmptyStructure ())
  <> (undefined :: Constructor (BitSequence 15) ()) (undefined :: Word64)
  <> (undefined :: Constructor (ConditionalStructure  'True  (CompoundStructure '[]) U8) ())
  <> (undefined :: Constructor (ConditionalStructure  'False  (CompoundStructure '[]) U8) ()) (undefined :: Word8)
  <> (undefined :: Constructor (CompoundStructure '[Name "x" U8, Name "y" S8]) ()) (undefined :: Word8 ) (undefined :: Int8 )
  <> (undefined :: Constructor (Name "x" U8 <> Name "y" S8 <> Name "z" S8) ()) (undefined :: Word8 ) (undefined :: Int8 ) (undefined :: Int8 )

_prettySpec ::
  Proxy (
      PrettyHigh '[
         PrettyStructure EmptyStructure
        , PrettyStructure (Anonymous (Name "foo" U8))
        , PrettyStructure U8
        , PrettyStructure S8
        , PrettyStructure FlagStructure
        , PrettyStructure (S 16 'LE)
        , PrettyStructure (S 32 'LE)
        , PrettyStructure (S 64 'LE)
        , PrettyStructure (U 16 'LE)
        , PrettyStructure (U 32 'LE)
        , PrettyStructure (U 64 'LE)
        , PrettyStructure (S 16 'BE)
        , PrettyStructure (S 32 'BE)
        , PrettyStructure (S 64 'BE)
        , PrettyStructure (U 16 'BE)
        , PrettyStructure (U 32 'BE)
        , PrettyStructure (U 64 'BE)
        , PrettyStructure ("x"//32 <> "y"//32 <> "z"//8)
        , PrettyStructure (ConditionalStructure 'False S8 U8)
        , PrettyStructure (ConditionalStructure 'True S8 U8)
        , PrettyStructure (ConstantStructure 123 U8)
        ]
    )
  -> String
_prettySpec px = showPretty px
